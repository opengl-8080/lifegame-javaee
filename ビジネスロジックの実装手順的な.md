# 「位置」クラスを実装する
とりあえず、もっともプリミティブで簡単そうな「位置」クラスから作っていきます。

```java
package gl8080.lifegame.logic;

public class Position {
}
```

空っぽのクラスを作ります。

そしたら、次に、テストクラスを作ります。

```java
package gl8080.lifegame.logic;

public class PositionTest {
}
```

準備完了です。

## 「位置」に必要な機能とは？
「位置」クラスは、「ゲーム」クラスから「セル」クラスのインスタンスを特定するために必要になります。

『この「ゲーム」のこの「位置」！』と言ったら、どの「セル」かが特定できるということです。


「位置」には縦と横の２つの座標があり、この組み合わせで「位置」を一意に識別うできなければなりません。

ということで、「位置」クラスにはこの**座標によって一意に識別できる仕組み**が必要そうです。

Java でいうと、 `equals()` メソッドと `hashCode()` の実装が関係してきます。

## `equals()` メソッドのテストを書く
方針は決まったので、 `equals()` メソッドからテストを書いてみます。

```java
package gl8080.lifegame.logic;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import org.junit.Test;

public class PositionTest {
    
    @Test
    public void 同じ縦横座標を持つインスタンス同士は_equalsメソッドで同じモノと判定される() throws Exception {
        // setup
        Position l1 = new Position(10, 14);
        Position l2 = new Position(10, 14);
        
        // exercise
        boolean actual = l1.equals(l2);
        
        // verify
        assertThat(actual, is(true));
    }
}
```

こんな感じでしょうか。

テストを実行すると、テストは失敗します。
Java では、 `equals()` メソッドはデフォルトでインスタンスが同じかどうかを判定するからです。

テストが通るように、 `Position` クラスの `equals()` メソッドを実装します。

```java
package gl8080.lifegame.logic;

public class Position {

    public Position(int i, int j) {
        // TODO 自動生成されたコンストラクター・スタブ
    }

    @Override
    public boolean equals(Object other) {
        return true;
    }
}
```

常に `true` を返すようにしておけば、とりあえずテストは通ります。

でも、当然このままでは目的を達成できません。
それはテストケースが不十分だからです。

テストケースを追加して、 `equals()` メソッドをどのように実装すべきか示しましょう。

```java
package gl8080.lifegame.logic;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

import org.junit.Test;

public class PositionTest {
    
    ...

    @Test
    public void 異なる縦横座標を持つインスタンス同士は_equalsメソッドで別物と判定される() throws Exception {
        // setup
        Position l1 = new Position(10, 14);
        Position l2 = new Position(10, 15);
        
        // exercise
        boolean actual = l1.equals(l2);
        
        // verify
        assertThat(actual, is(false));
    }
}
```

`equals()` メソッドが `false` を返すパターンを追加しました。

これを通るように、 `equals()` メソッドを実装します。

```java
package gl8080.lifegame.logic;

public class Position {
    
    private final int i;
    private final int j;

    public Position(int i, int j) {
        this.i = i;
        this.j = j;
    }

    @Override
    public boolean equals(Object o) {
        Position other = (Position) o;
        return this.i == other.i && this.j == other.j;
    }
}
```

これでテストは通るようになりました。
しかし、実装を見ているとまだまだ考慮が漏れているケースがあることに気づきます。

例えば、 `equals()` メソッドの引数に `null` や別のクラスのインスタンスが渡された場合はどうなるでしょう？
今のままだと、 `NullPointerException` や `ClassCastException` で落ちます。

また、 `equals()` メソッドをオーバーライドしたので `hashCode()` メソッドもオーバーライドしないと危険です。

その辺もいろいろ考慮し、さらに変数名などもリファクタリングした結果が以下です。

```java
package gl8080.lifegame.logic;

import java.util.Objects;

public class Position {
    
    private final int vertical;
    private final int horizontal;

    public Position(int vertical, int horizontal) {
        if (vertical < 0 || horizontal < 0) {
            throw new IllegalArgumentException("座標にマイナスは指定できません (" + vertical + ", " + horizontal + ")");
        }
        
        this.vertical = vertical;
        this.horizontal = horizontal;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) return false;
        if (!(o instanceof Position)) return false;
        
        Position other = (Position) o;
        return this.vertical == other.vertical && this.horizontal == other.horizontal;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(this.vertical, this.horizontal);
    }
}
```


